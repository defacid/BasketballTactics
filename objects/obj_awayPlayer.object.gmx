<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_away</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//Init
team = 1; //0 Home - 1 Away
ballHandler = 0;
dribble = 0;
pick = 0; //Setting a pick
pickDirection = -1; //0 - right, 1 - up, 2 - left, 3 - down;
passing = 0; //Whether the player is passing or not
passChance = 0;
throwIn = 0;
foulShot = 0; //Whether shooting a foul shot
shotChance = 0;
react = 1;
openness = 1.25;
goal = obj_homeHoop;
teammate = obj_homePlayer;
opponent = obj_awayPlayer;
teamColor = c_white;
teamColor = global.homeColor;
if (team) {
    goal = obj_awayHoop;
    teammate = obj_awayPlayer;
    opponent = obj_homePlayer;
    teamColor = global.awayColor;
}
target = goal;
selected = 0;
highlighted = 0;
held = 0;
locked = 0;

//Movment
canMove = 0;
canUndo = 0;
originX = x;
originY = y;
resetX = x;
resetY = y;
showCourtMap = 0; //DEBUG VAR - Shows floor map

//Reference variables
mySelf = self;
xx = x;
yy = y;
targetX = target.x;
targetY = target.y;
col = teamColor;
dir = point_direction(x, y, target.x, target.y);
dis = point_distance(x, y, target.x, target.y);
showTarget = 0;

//Default Player Stats
name = random_name();
faceColor = make_color_rgb(90, 55, 0);

var _r, _g, _b;
skin = irandom(9);
switch(skin) {
    case 0:
        _r = 125;
        _g = 65;
        _b = 55;
        break;
    case 1:
        _r = 196;
        _g = 144;
        _b = 124;
        break;
    case 2:
        _r = 197;
        _g = 164;
        _b = 126;
        break;
    case 3:
        _r = 221;
        _g = 181;
        _b = 148;
        break;
    case 4:
        _r = 80;
        _g = 35;
        _b = 0;
        break;
    case 5:
        _r = 232;
        _g = 202;
        _b = 179;
        break;
    case 6:
    default:
        _r = 90;
        _g = 45;
        _b = 20;
        break;
}
faceColor = make_color_rgb(_r, _g, _b);

//Default stats
position = "Default";
height = 6*12+7;
weight = 220;
post = 50;
midRange = 50;
threePoint = 50;
freeThrow = 50;
pass = 50;
quickness = 50;
stamina = 50;
strength = 50;
block = 50;
rebound = 50;
steal = 50;

//Generate stats
alarm[0] = 1;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//Set a random position
if (position == "Default") position = choose("Forward", "Center", "Guard");

//Generate stats
name = random_name(); //name[0] - First Name, name[1] - Last Name

var _r, _g, _b;
skin = irandom(9);
switch(skin) {
    case 0:
        _r = 125;
        _g = 65;
        _b = 55;
        break;
    case 1:
        _r = 196;
        _g = 144;
        _b = 124;
        break;
    case 2:
        _r = 197;
        _g = 164;
        _b = 126;
        break;
    case 3:
        _r = 221;
        _g = 181;
        _b = 148;
        break;
    case 4:
        _r = 80;
        _g = 35;
        _b = 0;
        break;
    case 5:
        _r = 232;
        _g = 202;
        _b = 179;
        break;
    case 6:
    default:
        _r = 90;
        _g = 45;
        _b = 20;
        break;
}
faceColor = make_color_rgb(_r, _g, _b);

switch(position) {
    case "Forward":
        height = 6*12 + 6 + round(variance()/2);
        weight = 220 + round(variance()*2);
        post = 80 + round(variance());
        midRange = 75 + round(variance());
        threePoint = 65 + round(variance());
        freeThrow = 75 + round(variance());
        pass = 65 + round(variance());
        quickness = 80 + round(variance());
        stamina = 70 + round(variance());
        strength = 75 + round(variance());
        block = 65 + round(variance());
        rebound = 75 + round(variance());
        steal = 70 + round(variance());
        break;
    case "Center":
        height = 7*12 + round(variance()/2);
        weight = 245 + round(variance()*2);
        post = 80 + round(variance());
        midRange = 70 + round(variance());
        threePoint = 60 + round(variance());
        freeThrow = 65 + round(variance());
        pass = 70 + round(variance());
        quickness = 70 + round(variance());
        stamina = 65 + round(variance());
        strength = 80 + round(variance());
        block = 75 + round(variance());
        rebound = 80 + round(variance());
        steal = 65 + round(variance());
        break;
    case "Guard":
        height = 6*12 + 2 + round(variance()/2);
        weight = 210 + round(variance()*2);
        post = 75 + round(variance());
        midRange = 75 + round(variance());
        threePoint = 80 + round(variance());
        freeThrow = 75 + round(variance());
        pass = 85 + round(variance());
        quickness = 75 + round(variance());
        stamina = 75 + round(variance());
        strength = 70 + round(variance());
        block = 55 + round(variance());
        rebound = 65 + round(variance());
        steal = 75 + round(variance());
        break;
    default:
        position = "ERROR";
        height = 5*12+8;
        weight = 160;
        post = 50;
        midRange = 50;
        threePoint = 50;
        freeThrow = 50;
        pass = 50;
        quickness = 50;
        stamina = 50;
        strength = 50;
        block = 50;
        rebound = 50;
        steal = 50;
        break;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (ballHandler) {
    var _xx = xx, _yy = yy, _mySelf = mySelf;
    with (opponent) {
        if (point_distance(_xx, _yy, x, y) &lt;= 32) target = _mySelf;
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//Determine openness
openness = 1.5;

var _mySelf = mySelf, _goal = goal;
with (opponent) {
    var _dis = point_distance(_mySelf.x, _mySelf.y, x, y);
    if (_dis &lt;= 64) {
        //If I'm close to the ball handler, let me use Steal skill to slightly lower openness
        _mySelf.openness -= .15*(steal/100)*(3 - _dis div 32);
        
        //If I'm closer to the goal than the ball handler, let me use Block skill to lower openness
        if (point_distance(x, y, _goal.x, _goal.y) &lt; point_distance(_mySelf.x, _mySelf.y, _goal.x, _goal.y)) {
            _mySelf.openness -= .25*(block/100)*(3 - _dis div 32);
        }
    }
}

//Determine targets and probabilities
if (global.possession == team) {
    target = goal;
    if (ballHandler) {
        //Shot Chance
        // SHOT COLOR IS NEAR PERFECT - DON'T MESS THIS UP
        if (foulShot) shotChance = freeThrow/100; //Free Throw
        else if (abs(x - target.x) &lt; 48 &amp;&amp; abs(y - target.y) &lt; 128) shotChance = 0.15 + (post/100)*(2-(point_distance(x, y, target.x, target.y))/196)/2; //Post
        else if (abs(x - target.x) &lt; 112 &amp;&amp; abs(y - target.y) &lt; 128 || abs(x - target.x) &lt; 80 &amp;&amp; abs(y - target.y) &lt; 160 || abs(x - target.x) &lt; 48 &amp;&amp; abs(y - target.y) &lt; 192) shotChance = 0.25 + (midRange/100)*(2-(point_distance(x, y, target.x, target.y))/320)/2; //Mid-range
        else shotChance = (threePoint/100)*(2-(point_distance(x, y, target.x, target.y))/320)/2; //Three Point
        
        shotChance = shotChance * openness;
        
        shotChance = clamp(shotChance, 0, 1);
        
        if (showCourtMap) {
            with(obj_floorUI) {
                surface_set_target(ui);
                //if (_mySelf.foulShot) draw_set_color(merge_color(c_red, c_green, _mySelf.freeThrow/100)); //Free Throw
                draw_set_alpha(.75);
                if (_mySelf.team) {
                    draw_set_color(c_fuchsia);
                    draw_rectangle(32, 32, 320, 320, 0); //Post//Three Point
                    draw_rectangle(32, 32, 320, 320, 0); //Post//Three Point
                    draw_set_color(c_orange);
                    draw_rectangle(64, 32, 288, 160, 0); //Midrange
                    draw_rectangle(96, 160, 256, 192, 0); //Midrange
                    draw_rectangle(128, 192, 224, 224, 0); //Midrange
                    draw_set_color(c_white);
                    draw_rectangle(128, 32, 224, 160, 0); //Post
                }
                else {
                    draw_set_color(c_fuchsia);
                    draw_rectangle(room_width-160-32, room_height-32, room_width-160-320, room_height-320, 0); //Post//Three Point
                    draw_rectangle(room_width-160-32, room_height-32, room_width-160-320, room_height-320, 0); //Post//Three Point
                    draw_set_color(c_orange);
                    draw_rectangle(room_width-160-64, room_height-32, room_width-160-288, room_height-160, 0); //Midrange
                    draw_rectangle(room_width-160-96, room_height-160, room_width-160-256, room_height-192, 0); //Midrange
                    draw_rectangle(room_width-160-128, room_height-192, room_width-160-224, room_height-224, 0); //Midrange
                    draw_set_color(c_white);
                    draw_rectangle(room_width-160-128, room_height-32, room_width-160-224, room_height-160, 0); //Post
                }
                surface_reset_target();
            }
        }
    }
}
else {
    if (instance_exists(opponent)) {
        target = instance_nearest(x, y, opponent);
    }
}

//Highlight player and show stats
if (point_distance(x, y, mouse_x, mouse_y) &lt; 16 &amp;&amp; obj_controller.titlePhase = 1) {
    if (!global.highlighted &amp;&amp; !obj_controller.canTurnover &amp;&amp; !instance_exists(obj_jumpBall)) {
        global.highlighted = 1;
        highlighted = 1;
        
        //Give controller player info
        obj_controller.name = name;
        obj_controller.team = team;
        obj_controller.position = position;
        obj_controller.faceColor = faceColor;
        obj_controller.height = height;
        obj_controller.weight = weight;
        obj_controller.post = post;
        obj_controller.midRange = midRange;
        obj_controller.threePoint = threePoint;
        obj_controller.freeThrow = freeThrow;
        obj_controller.pass = pass;
        obj_controller.quickness = quickness;
        obj_controller.stamina = stamina;
        obj_controller.strength = strength;
        obj_controller.block = block;
        obj_controller.rebound = rebound;
        obj_controller.steal = steal;
    }
    
    //Select player
    if (mouse_check_button_pressed(mb_left)) {
        if (global.actionClear) {
            if (!selected &amp;&amp; canUndo) {
                with (obj_homePlayer) {
                    if (!canMove) canUndo = 0;
                    selected = 0;
                }
                with (obj_awayPlayer) {
                    if (!canMove) canUndo = 0;
                    selected = 0;
                }
                global.selected = 1;
                selected = 1;
            }
            
            if (selected &amp;&amp; canMove &amp;&amp; !throwIn) {
                held = 1;
            }
        }
        else {
            var _selectedPlayer = obj_controller.selectedPlayer, _mySelf = mySelf;
            if (_selectedPlayer.ballHandler &amp;&amp; _selectedPlayer.team == _mySelf.team &amp;&amp; _selectedPlayer.passing &amp;&amp; _selectedPlayer.mySelf != _mySelf) {
                with(_selectedPlayer) {
                    if (throwIn) {
                        canMove = 1;
                        canUndo = 1;
                        throwIn = 0;
                    }
                    else {
                        canMove = 0;
                        canUndo = 0;
                    }
                    ballHandler = 0;
                    selected = 0;
                    global.selected = 0;
                    
                    var _openness;
                    _openness = pass/100 * openness * _mySelf.openness - 0.25 * (distance_to_object(_mySelf)/128);
                    _openness = clamp(_openness, 0, 1);
                    
                    var _ball = instance_create(x, y, obj_ball);
                    _ball.type = "pass";
                    _ball.shooter = mySelf;
                    _ball.target = _mySelf;
                    _ball.distance = point_distance(_ball.x, _ball.y, _mySelf.x, _mySelf.y) + (48 - random(96))*(1-_openness);
                    _ball.dir = point_direction(_ball.x, _ball.y, _mySelf.x, _mySelf.y) + (8 - random(16))*(1-_openness);
                    _ball.passSpeed = room_speed/2;
                }
            }
        }
    }
}

if (held &amp;&amp; mouse_check_button_released(mb_left)) held = 0;

var moved;
moved = 1;

if (selected) {
    if (canMove &amp;&amp; !throwIn) {
        var _originX = originX, _originY = originY, _col = col, _opponent = opponent, _teammate = teammate, _mySelf = mySelf, _moved = moved;
        
        with(obj_floorUI) {
            surface_set_target(ui);
            draw_set_alpha(0.75);
            draw_set_color(_col);
            draw_rectangle(_originX - 48, _originY - 48, _originX + 48, _originY + 48, 0);
            draw_rectangle(_originX - 16, _originY - 80, _originX + 16, _originY + 80, 0);
            draw_rectangle(_originX - 80, _originY - 16, _originX + 80, _originY + 16, 0);
            draw_set_alpha(1);
            draw_set_blend_mode(bm_subtract);
            draw_rectangle((_originX div 32)*32, (_originY div 32)*32, (_originX div 32)*32 + 32, (_originY div 32)*32 + 32, 0);
            draw_set_blend_mode(bm_normal);
            
            //Make sure to erase the opponent spaces and any potential movement paths that would be blocked by an opponent
            with(_opponent) {
                draw_set_alpha(1);
                draw_set_color(c_white);
                
                var opponentDir, opponentDis;
                opponentDir = point_direction(_originX, _originY, x, y);
                opponentDis = point_distance(_originX, _originY, x, y);
                opponentShiftDir = point_direction(_originX, _originY, x + pickShiftX*2, y + pickShiftY*2);
                if (opponentDis &lt;= 72) {
                    draw_set_blend_mode(bm_subtract);
                    draw_rectangle(x - 16, y - 16, x + 16, y + 16, 0);
                    draw_rectangle(((x + lengthdir_x(32, opponentDir)) div 32) * 32, ((y + lengthdir_y(32, opponentDir)) div 32) * 32, ((x + lengthdir_x(32, opponentDir)) div 32) * 32 + 32, ((y + lengthdir_y(32, opponentDir)) div 32) * 32 + 32, 0);
                    if (pick) {
                        draw_rectangle(x + pickShiftX*2 - 16, y + pickShiftY*2 - 16, x + pickShiftX*2 + 16, y + pickShiftY*2 + 16, 0);
                        draw_rectangle(((x + pickShiftX*2 + lengthdir_x(32, opponentShiftDir)) div 32) * 32, ((y + pickShiftY*2 + lengthdir_y(32, opponentShiftDir)) div 32) * 32, ((x + pickShiftX*2 + lengthdir_x(32, opponentShiftDir)) div 32) * 32 + 32, ((y + pickShiftY*2 + lengthdir_y(32, opponentShiftDir)) div 32) * 32 + 32, 0);
                    }
                    draw_set_blend_mode(bm_normal);
                }
                
                if (_mySelf.x &gt; x - 16 &amp;&amp; _mySelf.x &lt; x + 16 &amp;&amp; _mySelf.y &gt; y - 16 &amp;&amp; _mySelf.y &lt; y + 16) _moved = 0;
                if (_mySelf.x &gt; ((x + lengthdir_x(32, opponentDir)) div 32) * 32 &amp;&amp; _mySelf.x &lt; ((x + lengthdir_x(32, opponentDir)) div 32) * 32 + 32 &amp;&amp; _mySelf.y &gt; ((y + lengthdir_y(32, opponentDir)) div 32) * 32 &amp;&amp; _mySelf.y &lt; ((y + lengthdir_y(32, opponentDir)) div 32) * 32 + 32) _moved = 0;
                if (pick) {
                    if (_mySelf.x &gt; x + pickShiftX*2 - 16 &amp;&amp; _mySelf.x &lt; x + pickShiftX*2 + 16 &amp;&amp; _mySelf.y &gt; y + pickShiftY*2 - 16 &amp;&amp; _mySelf.y &lt; y + pickShiftY*2 + 16) _moved = 0;
                    if (_mySelf.x &gt; ((x + pickShiftX*2 + lengthdir_x(32, opponentShiftDir)) div 32) * 32 &amp;&amp; _mySelf.x &lt; ((x + pickShiftX*2 + lengthdir_x(32, opponentShiftDir)) div 32) * 32 + 32 &amp;&amp; _mySelf.y &gt; ((y + pickShiftY*2 + lengthdir_y(32, opponentShiftDir)) div 32) * 32 &amp;&amp; _mySelf.y &lt; ((y + pickShiftY*2 + lengthdir_y(32, opponentShiftDir)) div 32) * 32 + 32) _moved = 0;
                }
            }
            
            moved = _moved;
            
            //Make sure to erase the opponent spaces and any potential movement paths that would be blocked by a teammate
            with(_teammate) {
                if (mySelf != _mySelf) {
                    draw_set_alpha(1);
                    draw_set_color(c_white);
                    
                    var teammateDir, teammateDis;
                    teammateDir = point_direction(_originX, _originY, x, y);
                    teammateDis = point_distance(_originX, _originY, x, y);
                    if (teammateDis &lt;= 72) {
                        draw_set_blend_mode(bm_subtract);
                        draw_rectangle(x - 16, y - 16, x + 16, y + 16, 0);
                         if (!pick) draw_rectangle(((x + lengthdir_x(32, teammateDir)) div 32) * 32, ((y + lengthdir_y(32, teammateDir)) div 32) * 32, ((x + lengthdir_x(32, teammateDir)) div 32) * 32 + 32, ((y + lengthdir_y(32, teammateDir)) div 32) * 32 + 32, 0);
                        draw_set_blend_mode(bm_normal);
                    
                        if (_mySelf.x &gt; ((x + lengthdir_x(32, teammateDir)) div 32) * 32 &amp;&amp; _mySelf.x &lt; ((x + lengthdir_x(32, teammateDir)) div 32) * 32 + 32 &amp;&amp; _mySelf.y &gt; ((y + lengthdir_y(32, teammateDir)) div 32) * 32 &amp;&amp; _mySelf.y &lt; ((y + lengthdir_y(32, teammateDir)) div 32) * 32 + 32) _moved = 0;
                    }
                    
                    if (_mySelf.x &gt; x - 16 &amp;&amp; _mySelf.x &lt; x + 16 &amp;&amp; _mySelf.y &gt; y - 16 &amp;&amp; _mySelf.y &lt; y + 16) _moved = 0;
                }
            }
            
            moved = _moved;
            
            if (_mySelf.held &amp;&amp; _moved) {
                draw_set_alpha(0.75);
                draw_set_color(c_white);
                draw_rectangle((_mySelf.x div 32)*32, (_mySelf.y div 32)*32, (_mySelf.x div 32)*32 + 32, (_mySelf.y div 32)*32 + 32, 1);
                draw_rectangle((_mySelf.x div 32)*32 + 1, (_mySelf.y div 32)*32 + 1, (_mySelf.x div 32)*32 + 32 - 1, (_mySelf.y div 32)*32 + 32 - 1, 1);
            }
            
            surface_reset_target();
        }
    }
}

if (held) {
    x = mouse_x;
    y = mouse_y;
}
else {
    //Move back to origin if beyond movement tiles    
    if !(abs(x - originX) &lt; 48 &amp;&amp; abs(y - originY) &lt; 48) {
        if !((abs(x - originX) &lt; 16 &amp;&amp; abs(y - originY) &lt; 80) || (abs(x - originX) &lt; 80 &amp;&amp; abs(y - originY) &lt; 16)) {
            moved = 0;
        }
    }
    
    if (x &gt;= room_width - 160) moved = 0;
    
    //Place player once moved
    if (moved){
        x = (x div 32)*32 + 16;
        y = (y div 32)*32 + 16;
        if !(x == originX &amp;&amp; y == originY) {
            originX = x;
            originY = y;
            canMove = 0;
        }
    }
    else {
        x = originX;
        y = originY;
    }
}

if (ballHandler &amp;&amp; !throwIn &amp;&amp; !obj_controller.canTurnover &amp;&amp; (originX &lt; 32 || originY &lt; 32 || originX &gt; room_width - 160 - 32 || originY &gt; room_height - 32)) {
    canUndo = 0;
    with(obj_controller) {
        alarm[1] = room_speed*2;
        canTurnover = 1;
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="4" ename="obj_ball">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//FIX BLOCKING NOW!!!!

/*if (react &amp;&amp; distance_to_object(other) &lt; 16) {
    //Try to block
    var blockAttempt, shooter;
    shooter = other.shooter;
    
    if (shooter.team != team &amp;&amp; point_distance(shooter.x, shooter.y, x, y) &lt; 48){
        blockAttempt = (1 - shooter.openness) + (block/100) + random(1)/2;
        
        if (blockAttempt &gt;= 1) {
            other.distance = 16 + random(80);
            other.arc = 0;
            other.dir = other.dir + 180 + 60 - random(120);
            other.type = "blocked";
        }
    }
    react = 0;
}
*/
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//Update all reference variables
xx = x;
yy = y;
targetX = target.x;
targetY = target.y;

if (pick) {
    if (pickDirection = -1) {
        var mouseDis, mouseDir, _mySelf, _tempPick;
        mouseDis = point_distance(x, y, mouse_x, mouse_y);
        mouseDir = point_direction(x, y, mouse_x, mouse_y);
        _mySelf = mySelf;
        _tempPick = -1;
        for (i=0; i&lt;4; i++) {
            var _clear = 1;
            for (j=0; j &lt; global.playerCount; j++) {
                if (obj_controller.player[j].x == x + lengthdir_x(32, i*90) &amp;&amp; obj_controller.player[j].y == y + lengthdir_y(32, i*90)) _clear = 0;
            }
            
            if (_clear) {
                if (point_distance(x + lengthdir_x(32, i*90), y + lengthdir_y(32, i*90), mouse_x, mouse_y) &lt; 16) {
                    _tempPick = i;
                    if (mouse_check_button_pressed(mb_left)) {
                        canUndo = 0;
                        pickDirection = i;
                        global.actionClear = 1;
                    }
                    draw_set_color(c_white);
                }
                else draw_set_color(teamColor);
                
                var _i = i;
                
                with(obj_skyUI) {
                    surface_set_target(ui);
                    draw_set_alpha(1);
                    draw_circle(_mySelf.x + lengthdir_x(32, _i*90), _mySelf.y + lengthdir_y(32, _i*90), 16, 0);
                    draw_set_alpha(0.5);
                    draw_set_blend_mode(bm_subtract);
                    draw_set_color(c_white);
                    draw_circle(_mySelf.x + lengthdir_x(32, _i*90), _mySelf.y + lengthdir_y(32, _i*90), 12, 0);
                    draw_set_blend_mode(bm_normal);
                    surface_reset_target();
                }
            }
        }
        if (_tempPick &gt;= 0) {
            dir = 360*(_tempPick-1)/4;
            pickShiftX = lengthdir_x(16, dir+90);
            pickShiftY = lengthdir_y(16, dir+90);
        }
        else {
            dir = mouseDir-90;
            pickShiftX = 0;
            pickShiftY = 0;
        }
        
    }
    else {
        dir = 360*(pickDirection-1)/4;
        pickShiftX = lengthdir_x(16, dir+90);
        pickShiftY = lengthdir_y(16, dir+90);
    }
    
    draw_set_color(teamColor);
    draw_set_alpha(0.25);
    draw_circle(x, y, 16, 1);
    draw_rectangle(x - 16, y - 16, x + 16, y + 16, 0);
    draw_rectangle(x + pickShiftX*2 - 16, y + pickShiftY*2 - 16, x + pickShiftX*2 + 16, y + pickShiftY*2 + 16, 0);
}
else {
    dir = point_direction(x, y, target.x, target.y);
    pickShiftX = 0;
    pickShiftY = 0;
}
dis = point_distance(x, y, target.x, target.y);
showTarget = 0;

if (global.possession == team) {
    if (ballHandler) {
        dribble = (dribble + 15) mod 360;
        draw_sprite_ext(spr_basketball, 0, x + lengthdir_x(8, dir - 90) + lengthdir_x(8, dir), y + lengthdir_y(8, dir - 90) + lengthdir_y(8, dir), 0.35 + 0.1*sin(degtorad(dribble)), 0.35 + 0.1*sin(degtorad(dribble)), 0, c_white, 1);
        showTarget = 1;
    }
}
else {
    if (instance_exists(opponent)) {
        showTarget = 1;
    }
}

if (canMove &amp;&amp; global.turn == team) {
    //Outline
    draw_set_alpha(1);
    draw_set_color(c_white);
    draw_circle(x + pickShiftX + lengthdir_x(10, dir + 90), y + pickShiftY + lengthdir_y(10, dir + 90), 7, 0);
    draw_circle(x + pickShiftX + lengthdir_x(10, dir - 90), y + pickShiftY + lengthdir_y(10, dir - 90), 7, 0);
    draw_line_width(x + pickShiftX + lengthdir_x(11, dir + 90), y + pickShiftY + lengthdir_y(11, dir + 90), x + pickShiftX + lengthdir_x(11, dir - 90), y + pickShiftY + lengthdir_y(11, dir - 90), 18);
}

if (selected) {
    //Outline
    draw_set_alpha(1);
    draw_set_color(c_white);
    draw_circle(x + pickShiftX + lengthdir_x(10, dir + 90), y + pickShiftY + lengthdir_y(10, dir + 90), 8, 0);
    draw_circle(x + pickShiftX + lengthdir_x(10, dir - 90), y + pickShiftY + lengthdir_y(10, dir - 90), 8, 0);
    draw_line_width(x + pickShiftX + lengthdir_x(11, dir + 90), y + pickShiftY + lengthdir_y(11, dir + 90), x + pickShiftX + lengthdir_x(11, dir - 90), y + pickShiftY + lengthdir_y(11, dir - 90), 20);
}

if (highlighted) {
    
    //TEMPORARY DEBUG
    //draw_set_color(c_white);
    //draw_set_font(fnt_statName);
    //draw_text(x, y - string_height(string(openness)), string(openness));
    //draw_text(x, y - string_height(string(passChance))*2, string(passChance));
    //TEMPORARY
    
    var _bottom = 0;
    if (y &gt;= room_height - 64) _bottom = 1;
    
    draw_set_font(fnt_timerName);
    draw_set_alpha(0.5);
    draw_set_color(teamColor);
    for(i=0; i&lt;8; i++) draw_text(x + pickShiftX - string_width(name[1])/2 + lengthdir_x(1, i*(360/8)), y + pickShiftY + 12 + lengthdir_y(1, i*(360/8)) - 40 * _bottom, name[1]);
    draw_set_alpha(1);
    draw_set_color(c_white);
    draw_text(x + pickShiftX - string_width(name[1])/2, y + pickShiftY + 12 - 40 * _bottom, name[1]);
}

if (showTarget &amp;&amp; team == global.turn) {
    var _xx = xx, _yy = yy, _col = col, _goal = goal, _teammate = teammate, _opponent = opponent, _target = target, _targetX = targetX, _targetY = targetY, _mySelf = mySelf;
    with(obj_skyUI) {
        surface_set_target(ui);
        
        if (_target == _goal) {
            if (_mySelf.passing &amp;&amp; _mySelf.selected) {
                with(_teammate) {
                    if (mySelf != _mySelf &amp;&amp; !pick) {
                        var _openness;
                        _openness = pass/100 * openness * _mySelf.openness - 0.25 * (distance_to_object(_mySelf)/128);
                        _openness = clamp(_openness, 0, 1);
                        
                        draw_set_alpha(0.75);
                        draw_set_color(_col);
                        draw_line_width(_xx, _yy, x, y, 4);
                        
                        draw_set_alpha(.85);
                        draw_set_color(merge_color(c_red, c_lime, _openness)); // Red to green based on chance of passing success (passing + teammate openness - opponent steal)
                        if (point_distance(x, y, mouse_x, mouse_y) &lt; 16) draw_set_color(c_white);
                        draw_circle(x, y, 16, 0);
                        draw_set_blend_mode(bm_subtract);
                        draw_set_color(c_white);
                        draw_circle(x, y, 12, 0);
                        draw_set_blend_mode(bm_normal);
                    }
                }
            }
            
            if (_mySelf.ballHandler &amp;&amp; _mySelf.passing &amp;&amp; !_mySelf.throwIn) {
                draw_set_alpha(1);
                // Red to green based on chance of shooting success (shooting skill for court area + openness - goal distance - opponent block)
                var _shootingChance;
                _shootingChance = (_mySelf.shotChance - 0.5)*2;
                _shootingChance = clamp(_shootingChance, 0, 1);
                
                draw_set_color(merge_color(c_red, c_green, _shootingChance));
                draw_line_width(_xx, _yy, _targetX, _targetY, 4);
                if (point_distance(_targetX, _targetY, mouse_x, mouse_y) &lt; 16 &amp;&amp; _mySelf.passing) draw_set_color(c_white);
                draw_circle(_targetX, _targetY, 16, 0);
                draw_set_blend_mode(bm_subtract);
                draw_set_color(c_white);
                draw_circle(_targetX, _targetY, 12, 0);
                draw_set_blend_mode(bm_normal);
                
                
                //CHECK SHOOTING AREA IS ACCURATE
                /*
                if (_mySelf.foulShot) draw_set_color(c_black); //Free Throw
                else if (abs(_xx - _targetX) &lt; 48 &amp;&amp; abs(_yy - _targetY) &lt; 128) draw_set_color(c_white); //Post
                else if (abs(_xx - _targetX) &lt; 112 &amp;&amp; abs(_yy - _targetY) &lt; 128 || abs(_xx - _targetX) &lt; 80 &amp;&amp; abs(_yy - _targetY) &lt; 160 || abs(_xx - _targetX) &lt; 48 &amp;&amp; abs(_yy - _targetY) &lt; 192) draw_set_color(c_orange); //Mid-range
                else draw_set_color(c_fuchsia); //Three Point
                draw_line_width(_xx, _yy, _targetX, _targetY, 4);
                draw_circle(_targetX, _targetY, 16, 0);
                draw_set_blend_mode(bm_subtract);
                draw_set_color(c_white);
                draw_circle(_targetX, _targetY, 12, 0);
                draw_set_blend_mode(bm_normal);
                */
            }
        }
        else {
            with(_opponent) {
                if (point_distance(_xx, _yy, x, y) &lt;= 64) {
                    draw_set_alpha(((1 - point_distance(_xx, _yy, x, y)/96))*_mySelf.block/50); // Alpha based on chance of block success
                    draw_set_color(_col);
                    draw_line_width(_xx, _yy, x, y, 4);
                    draw_circle(x, y, 16, 0);
                    draw_set_blend_mode(bm_subtract);
                    draw_set_color(c_white);
                    draw_circle(x, y, 12, 0);
                    draw_set_blend_mode(bm_normal);
                }
            }
        }
        surface_reset_target();
    }
}

//Shadow
draw_set_alpha(0.1);
draw_set_color(c_black);
draw_circle(x + pickShiftX + lengthdir_x(10, dir + 90) + 1, y + pickShiftY + lengthdir_y(10, dir + 90) + 2, 7, 0);
draw_circle(x + pickShiftX + lengthdir_x(10, dir - 90) + 1, y + pickShiftY + lengthdir_y(10, dir - 90) + 2, 7, 0);
draw_line_width(x + pickShiftX + lengthdir_x(11, dir + 90), y + pickShiftY + lengthdir_y(11, dir + 90) + 1, x + pickShiftX + lengthdir_x(11, dir - 90), y + pickShiftY + lengthdir_y(11, dir - 90) + 2, 18);

//Arms
draw_set_alpha(1);
draw_set_color(faceColor);
draw_circle(x + pickShiftX + lengthdir_x(10, dir + 90), y + pickShiftY + lengthdir_y(10, dir + 90), 6, 0);
draw_circle(x + pickShiftX + lengthdir_x(10, dir - 90), y + pickShiftY + lengthdir_y(10, dir - 90), 6, 0);

//Jersey
draw_set_alpha(1);
draw_set_color(teamColor);
draw_line_width(x + pickShiftX + lengthdir_x(10, dir + 90), y + pickShiftY + lengthdir_y(10, dir + 90), x + pickShiftX + lengthdir_x(10, dir - 90), y + pickShiftY + lengthdir_y(10, dir - 90), 16);

//Head Shadow
draw_set_alpha(0.1);
draw_set_color(c_black);
draw_circle(x + pickShiftX, y + pickShiftY - 1, 6, 0);
draw_set_alpha(1);

//Head
draw_set_color(faceColor);
draw_circle(x + pickShiftX, y + pickShiftY - 2, 6, 0);
draw_set_alpha(1);
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
